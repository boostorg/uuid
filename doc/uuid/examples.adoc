[#examples]
= Examples

:idprefix: examples_
:cpp: C++

== Tagging

[source,c++]
----
// example of tagging an object with a uuid
// see boost/libs/uuid/test/test_tagging.cpp

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>

class object
{
public:
    object()
        : tag(boost::uuids::random_generator()())
        , state(0)
    {}

    explicit object(int state)
        : tag(boost::uuids::random_generator()())
        , state(state)
    {}

    object(object const& rhs)
        : tag(rhs.tag)
        , state(rhs.state)
    {}

    bool operator==(object const& rhs) const {
        return tag == rhs.tag;
    }

    object& operator=(object const& rhs) {
        tag = rhs.tag;
        state = rhs.state;
    }

    int get_state() const { return state; }
    void set_state(int new_state) { state = new_state; }

private:
    boost::uuids::uuid tag;

    int state;
};

object o1(1);
object o2 = o1;
o2.set_state(2);
assert(o1 == o2);

object o3(3);
assert(o1 != o3);
assert(o2 != o3);
----

== POD Efficiencies

This library implements a UUID as a POD allowing a UUID to be used in the most efficient ways, including using memcpy, and aggregate initializers. A drawback is that a POD can not have any constructors, and thus declaring a UUID will not initialize it to a value generated by one of the defined mechanisms. But a class based on a UUID can be defined that does initialize itself to a value generated by one of the defined mechanisms.

Note that `boost::is_pod` is specialized for `boost::uuids::uuid` and depends on https://www.boost.org/libs/type_traits[Boost.TypeTraits]. Define `BOOST_UUID_NO_TYPE_TRAITS` before including `boost/uuid/uuid.hpp` to remove the dependency on Boost.TypeTraits.

[source,c++]
----
// example using memcpy and aggregate initializers
// example of a class uuid see boost/libs/uuid/test/test_uuid_class.cpp

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>

{ // example using memcpy
    unsigned char uuid_data[16];
    // fill uuid_data

    boost::uuids::uuid u;

    memcpy(&u, uuid_data, 16);
}

{ // example using aggregate initializers
    boost::uuids::uuid u =
    { 0x12 ,0x34, 0x56, 0x78
    , 0x90, 0xab
    , 0xcd, 0xef
    , 0x12, 0x34
    , 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef
    };
}

// example of creating a uuid class that
// initializes the uuid in the constructor
// using a defined mechanism

class uuid_class : public boost::uuids::uuid
{
public:
    uuid_class()
        : boost::uuids::uuid(boost::uuids::random_generator()())
    {}

    explicit uuid_class(boost::uuids::uuid const& u)
        : boost::uuids::uuid(u)
    {}

    operator boost::uuids::uuid() {
        return static_cast<boost::uuids::uuid&>(*this);
    }

    operator boost::uuids::uuid() const {
        return static_cast<boost::uuids::uuid const&>(*this);
    }
};

uuid_class u1;
uuid_class u2;

assert(u1 != u2);
----

== Byte Extraction

It is sometimes useful to get at the 16 bytes of a *uuid* directly. Typical use is as follows:

[source,c++]
----
boost::uuids::uuid u;
std::vector<uint8_t> v(u.size());
std::copy(u.begin(), u.end(), v.begin());
----

Note: `boost::uuids::uuid::size()` always returns 16.
